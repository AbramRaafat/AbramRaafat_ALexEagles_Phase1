import cv2 as cv
import numpy as np
import os

def getJPG(dirc):
    img_dirc = [img  for img in os.listdir(dirc) if img.endswith(".jpg")]
    return img_dirc
def rbgTGray(image):
    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    return gray
def imgProcessing(image):
    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    blur = cv.GaussianBlur(gray, (5,5), 0) # to ensure a smothe image
    threshhold, bin_Image = cv.threshold(blur, 120, 255, cv.THRESH_BINARY) # use lower threshold since the background in complete black
    return bin_Image


def detectHole(bin_image):
    # input --> binary imag
    # return the size of each hole
    hole_cont, hier = cv.findContours(bin_image, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
    inner_contour = min(hole_cont, key=cv.contourArea)
    center, radius = cv.minEnclosingCircle(inner_contour)
    center = tuple(map(int, center))
    if radius > 100:
        radius = 0
    return radius,center

def align_Images(samp_img, ideal_img): # function to ensure the gears are aligned
    """
    this function aimed to solve advance problem such as the two gears are not aligned
    this function generated by claude 3.5 and need to be tuned for further integration with the code
    and to ensure that there aren't furure errors
    
    """
    samp_img_features, des1 = cv.ORB_create().detectAndCompute(samp_img, None)
    ideal_img_features, des2 = cv.ORB_create().detectAndCompute(ideal_img, None)
    
    bf = cv.BFMatcher(cv.NORM_HAMMING, crossCheck=True)
    matches = bf.match(des1, des2)
    matches = sorted(matches, key=lambda x: x.distance)
    
    src_pts = np.float32([samp_img_features[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)
    dst_pts = np.float32([ideal_img_features[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)
    
    M, _ = cv.findHomography(src_pts, dst_pts, cv.RANSAC, 5.0)
    return cv.warpPerspective(samp_img, M, ideal_img.shape) # return the samp_imgle wraped around the ideal_img samp_imgle
def defects_detection(samp_img, ideal_img, center):
    #samp_img = align_Images(samp_img, ideal_img)
    xorImg = cv.bitwise_xor(samp_img, ideal_img)
    xorImg = cv.circle(xorImg, center, 60, (0,0,0), -1) # to ensure the hole doesn't count
    contours, heir = cv.findContours(xorImg, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
    AreaContours = list(map(cv.contourArea,contours))
    broken = len(list(filter(lambda x : (x>450 and x < 1000) , AreaContours)))
    worn = len(list(filter(lambda x : (x>100 and x < 450) , AreaContours)))
    
    
    return broken, worn
    
    